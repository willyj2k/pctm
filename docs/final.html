<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <style>
        body {
            padding: 100px;
            margin: auto;
            text-align: left;
            font-weight: 400;
            font-family: 'Open Sans', sans-serif;
            font-size: 12pt;
            color: #000000;
        }

        h1, h2, h3, h4 {
            font-family: 'Source Sans Pro', sans-serif;
        }

        /*
        div.padded {
          padding-top: 0px;
          padding-right: 100px;
          padding-bottom: 0.25in;
          padding-left: 100px;
        }
        */
    </style>
    <title>Final Report</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="style.css" media="screen"/>
</head>
<body>
<br/>
<h1 align="middle">Final Report: Point Cloud to Mesh</h1>
<h2 align="middle">Evan Chang, Rene Lee, William Jow</h2>
<br>
<br>

<!--<a href="https://drive.google.com/open?id=1qWXYMsk_iGdAqTHUru9skpUl9y8UUay7" target="_blank">Video Explanation</a>-->


<div class="padded">
    <h2>Abstract</h2>
    <p>In this project, we parsed .ply files in order to get 3D vertices or our point cloud. Using these vertices, we
        calculated the normals. To calculate the vertex normals, we took advantage of the already calculated spatial
        mapping that will be used for the ball pivot algorithm. With spatial mapping, we were able to calculate the
        centroid of every vertex closeby and calculated a vector from the centroid to the vertex in question. The
        “normal” was then simply the direction of that vector, and we updated the normal attribute in each vertex. Then,
        with the point cloud and normals we implemented the ball-pivoting algorithm in order to create a 3D mesh.
    </p>

    <br>

    <h2>Technical Approach</h2>

    <h3>Parsing .ply Files</h3>
    <p>To parse .ply files, our group decided to utilize the rply library. Using this library, parsing each line in the
        .ply file for vertex positions became rather straightforward, and we were able to successfully extract a list of
        Vector3D vertices from passed in ply files. To render .ply files, we took advantage of the already existing
        rendering code inside meshEdit.cpp from project 2. Our group decided to not utilize the halfedge data structure
        though, and as a result, a majority of the code in meshEdit was unused. However, we were able to follow some of
        the rendering patterns from the file, and were able to successfully render points and edges from our algorithm
        results. Unfortunately, our group was unable to figure out the opengl shader program, and as such our renderings
        only came out in a single color.
    </p>

    <h3>Ball Pivoting Algorithm</h3>
    <h4>Overview</h4>
    <p>We followed the algorithm detailed in the research paper: The Ball-Pivoting Algorithm for Surface Reconstruction.
        The pseudocode given for this algorithm required us to write separate helper functions such as
        find_seed_triangle, ball_pivot, join, and glue.</p>

    <h4>Spatial Mapping</h4>
    <p>Given a list of points, we created a spatial map for these points in order to speed up the process of finding the
        seed triangle. Each 3D box had a height, width, and depth of 2 * (radius of the sphere). The hash position and
        create spatial grid functions were essentially the same as our project 4 clothsim's spatial mapping
        functions.</p>

    <h4>Find Seed Triangle</h4>
    <p></p>

    <h4>Ball Pivot</h4>
    <p></p>

    <h4>Join</h4>
    <p>To generate triangles from the ball pivot algorithm, we utilized two helper methods to add and remove edges to a
        growing list of edge loops. To add edges, we used a helper method called join, which adds two edges eik and ekj
        connecting an unused vertex vk touched by the ball in the ball pivot algorithm when pivoting on an active edge
        eij. The resulting triangle is stored in an external list that keeps track of every triangle we will render at
        the end of the algorithm, and the edge eij is removed from the front and eik and ekj are added to the front to
        be expanded upon later. If the vertex vk is actually already used, then that means the vertex is either inside
        the mesh, which means the edge eij should be marked as a boundary edge, or the vertex vk is already in the front
        and we need to remove potentially repeating active edges in the front. This removal of extra edges is taken care
        of in the second helper function glue().</p>

    <h4>Glue</h4>
    <p>The glue function serves to remove any extraneous edges created by the join function above, essentially “gluing”
        the edges together and removing sub-loops that could be formed in the front. To check for this, glue takes in a
        newly created edge eij and checks the loops in the front for the existence of any opposing edges eji. According
        to the paper, there are four possible scenarios if an opposing edge eji exists and four different ways to handle
        each scenario. In the first scenario, the opposing edge eji and eij are the only two edges in the loop. If this
        happens, we know that eij has already been checked and thus both edges can be removed from the front and the
        loop is deleted. In the second scenario, both edges belong to the same loop and are adjacent to each other. If
        this occurs, we simply remove the sub-loop created by the opposing edges and the loop in the front is therefore
        shortened. In the third scenario, both edges belong to the same loop, but are not adjacent to each other. In
        this situation, we remove the loop created by the opposing edges and split the original loop into two. In the
        fourth scenario, the edges do not belong to the same loop, and we must then connect both loops into one. To do
        this, we take the beginning of loop1 and connect that to the end of loop2 and vice versa, deleting the sub-loop
        created by the opposing edges. After running glue, any opposing edges will be removed from the front to prevent
        any repeating active edges, and the algorithm can proceed as usual.</p>


    <br>

    <h2>Results</h2>

    <br>

    <h2>References</h2>

    <br>

    <h2>Contributions</h2>

</div>
</body>
</html>
